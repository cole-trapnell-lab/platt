% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deg.R
\name{classify_genes_over_graph}
\alias{classify_genes_over_graph}
\title{#' similar to fit_genotype_ccm
#' @param ccs
#' @param genotype
#' @param ctrl_ids
#' @param perturbation_col
#' @param interval_col
#' @param cell_groups
fit_genotype_deg = function(ccs,
genotype,
ctrl_ids = c("Control"),
perturbation_col = "perturbation",
interval_col = "timepoint",
assembly_time_start = 18,
assembly_time_stop= 72,
cell_groups = NULL,
cores = 1,
min_samples_detected = 2,
min_cells_per_pseudobulk = 3,
... ) {

expts = unique(colData(ccs)$expt)

if (is.null(assembly_time_start)){
knockout_time_start = min(colData(ccs)[\link{interval_col}])
}else{
knockout_time_start = assembly_time_start
}

if (is.null(assembly_time_stop)){
knockout_time_stop = max(colData(subset_ccs)[\link{interval_col}])
}else{
knockout_time_stop = assembly_time_stop
}

num_knockout_timepoints = length(unique(colData(subset_ccs)[\link{interval_col}]))

message(paste("\ttime range:", knockout_time_start, "to", knockout_time_stop))
subset_ccs = ccs[,( replace_na(colData(ccs)[\link{perturbation_col}] == genotype, F) | colData(ccs)[\link{perturbation_col}] \%in\% ctrl_ids) & colData(ccs)$expt \%in\% expts]

colData(subset_ccs)$knockout = colData(subset_ccs)[\link{perturbation_col}] == genotype
subset_ccs = subset_ccs[,(colData(subset_ccs)[\link{interval_col}] >= knockout_time_start & colData(subset_ccs)[\link{interval_col}] <= knockout_time_stop)]

colData(subset_ccs@cds)$knockout = colData(subset_ccs@cds)[\link{perturbation_col}] == genotype

pb_cds = hooke:::pseudobulk_ccs_for_states(subset_ccs)subset to genes that are expressed over a certain min value

expr_over_thresh = normalized_counts(pb_cds, "size_only", pseudocount = 0)
genes_to_test = which(Matrix::rowSums(expr_over_thresh) >= min_samples_detected)
pb_cds = pb_cds\link{genes_to_test,}

pseudobulks_to_test = which(colData(pb_cds)$num_cells_in_group >= min_cells_per_pseudobulk)
pb_cds = pb_cds\link{,pseudobulks_to_test}

pb_cds = hooke:::add_covariate(subset_ccs, pb_cds, "knockout")

if (is.null(cell_groups)) {
cell_groups = rownames(counts(ccs))
}

if (is.null(perturbations)) {
perturbations = unique(colData(pb_cds)[\link{perturbation_col}])
}cell_group_models = lapply(perturbations, function(perturbation) {

cell_group_models = lapply(cell_groups, function(cell_group) {

\if{html}{\out{<div class="sourceCode">}}\preformatted{# perturb_pb_cds = pb_cds[, colData(pb_cds)[[perturbation_col]] == perturbation]
cg_pb_cds = pb_cds[, colData(pb_cds)[[state_term]] == cell_group]

# message(paste0("fitting regression models for ", perturbation))
message(paste0("fitting regression models for ", cell_group))

pb_group_models = fit_models(cg_pb_cds,
                             model_formula_str=paste("~ 0 + knockout", ),
                             weights=colData(pb_cds)$num_cells_in_group,
                             cores=cores) \%>\% dplyr::select(gene_short_name, id, model, model_summary)

message(paste0("fitting regression models for ", cell_group))

pb_group_models = coefficient_table(pb_group_models) \%>\%
  dplyr::select(gene_short_name, id, term, estimate, std_err) \%>\%
  mutate(term = stringr::str_replace_all(term, state_term, ""))
estimate_matrix = pb_group_models \%>\% dplyr::select(id, term, estimate)
estimate_matrix = estimate_matrix \%>\% mutate(term = factor(term, levels=unique(colData(cg_pb_cds)[,"knockout"])))
estimate_matrix = estimate_matrix \%>\% tidyr::pivot_wider(names_from=term, values_from=estimate, values_fill=0)

gene_ids = estimate_matrix$id
estimate_matrix$id = NULL
estimate_matrix = as.matrix(estimate_matrix)
row.names(estimate_matrix) = gene_ids
colnames(estimate_matrix) = as.character(colnames(estimate_matrix))

stderr_matrix = pb_group_models \%>\% dplyr::select(id, term, std_err)
estimate_matrix = estimate_matrix \%>\% mutate(term = factor(term, levels=unique(colData(cg_pb_cds)[,"knockout"])))
stderr_matrix = stderr_matrix \%>\% tidyr::pivot_wider(names_from=term, values_from=std_err, values_fill=0)

gene_ids = stderr_matrix$id
stderr_matrix$id = NULL
stderr_matrix = as.matrix(stderr_matrix)
row.names(stderr_matrix) = gene_ids
colnames(stderr_matrix) = as.character(colnames(stderr_matrix))

# states_to_assess = intersect(as.character(unique(colData(pb_cds)[,state_term])), unlist(igraph::V(state_graph)$name))
# cell_states = tibble(cell_state = states_to_assess)

# cell_states = cell_states \%>\%
#   dplyr::mutate(gene_classes = purrr::map(.f = purrr::possibly(
#     classify_genes_in_cell_state, NA_real_), .x = cell_state,
#     state_graph, estimate_matrix, stderr_matrix, state_term,
#     log_fc_thresh=log_fc_thresh,
#     abs_expr_thresh = abs_expr_thresh,
#     sig_thresh=sig_thresh,
#     cores=cores))
# 
# cell_states = cell_states \%>\%
#   filter(is.na(gene_classes) == FALSE) \%>\%
#   dplyr::mutate(gene_class_scores = purrr::map2(.f = purrr::possibly(
#     score_genes_for_expression_pattern, NA_real_),
#     .x = cell_state,
#     .y = gene_classes,
#     state_graph,
#     estimate_matrix))
  
# cell_states
}\if{html}{\out{</div>}}}
\usage{
classify_genes_over_graph(
  ccs,
  state_graph,
  gene_ids = NULL,
  group_nodes_by = NULL,
  assembly_group = NULL,
  label_nodes_by = "cell_state",
  log_fc_thresh = 1,
  abs_expr_thresh = 0.001,
  sig_thresh = 0.05,
  min_samples_detected = 2,
  min_cells_per_pseudobulk = 3,
  cores = 1,
  ...
)
}
\description{

}
\details{
#' to do: do i want to subset by time or do i not care
#' @param ccs
#' @param perturbation_col
#' @param control_ids
#' @param cell_groups
fit_mt_deg_models = function(ccs,
perturbation_col,
control_ids,
cell_groups = NULL,
num_threads = 1) {

ccs@cds_coldata[\link{"perturb_name"}] = ccs@cds_coldata[\link{perturbation_col}]

perturb_df = ccs@cds_coldata \%>\%
as_tibble() \%>\%
dplyr::select(perturb_name) \%>\%
filter(!perturb_name \%in\% ctrl_ids) \%>\%
distinct()

perturb_models_tbl = perturb_df \%>\%
purrr::map(.f = fit_genotype_deg,
.x = perturb_name,
control_ids = control_ids,
cell_groups = cell_groups)

return(perturb_models_tbl)
}
Classify each gene's pattern of expression in each state in a state transition graph
}
